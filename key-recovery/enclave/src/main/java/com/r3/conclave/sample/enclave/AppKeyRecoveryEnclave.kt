package com.r3.conclave.sample.enclave

import com.r3.conclave.client.EnclaveConstraint
import com.r3.conclave.client.InvalidEnclaveException
import com.r3.conclave.common.EnclaveInstanceInfo
import com.r3.conclave.enclave.Enclave
import com.r3.conclave.enclave.EnclavePostOffice
import com.r3.conclave.mail.EnclaveMail
import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.KSerializer
import kotlinx.serialization.SerializationStrategy
import kotlinx.serialization.protobuf.ProtoBuf
import java.security.KeyPair
import java.security.PublicKey

/**
 * TODO
 */
// TODO no enclave init - JIRA for discussion Shams
@ExperimentalSerializationApi
class AppKeyRecoveryEnclave : Enclave() {
    private val simpleKeyStore = SimpleInMemoryKeyStore()

    // We need this for attesting the KDE, so we either obtain it from the file
    // or, we ask for the attestation passed via host and then we check with the constraints
    private lateinit var keyDerivationEnclaveInstanceInfo: EnclaveInstanceInfo

    // CONSTRAINTS FOR KEY DERIVATION ENCLAVE
    // TODO fill it in with real values, it's placeholder
    private val keyDerivationEnclaveMeasurment = "C:2797b9581b9377d41a8ffc45990335048e79c976a6bbb4e7692ecad699a55317"

    //    private val siginingKeyHash =
//        "S:360585776942A4E8A6BD70743E7C114A81F9E901BF90371D27D55A241C738AD9"
    private val prodID = "PROD:1"
    private val revocationLevel = "REVOKE:1"
    private val security = "SEC:INSECURE"

    // For authentication of the KDE enclave
    //
    private val keyDerivationEnclaveConstraints = EnclaveConstraint.parse(
            (keyDerivationEnclaveMeasurment + prodID + revocationLevel + security)
    )

    // todo this is probably not needed if we nail the constraints
    // todo think of the overwriting the key and data migration
    private val keyRequested: Boolean = false

    // TODO SIDE CHANNELS, think how we could obfuscate the fact that we are handling key request/response
    //  should we have special messages and reserved topic? we need routing coordination from a host perspective anyway...
    override fun receiveMail(id: Long, mail: EnclaveMail, routingHint: String?) {
        routingHint!!  // Ensure that the routingHint isn't null
        // TODO REFACTOR don't pass it as routing hint/reuse header/body
        if (routingHint == SHARED_KEY_HINT) {
            loadSharedKey(mail)
        } else if (routingHint == SELF_HINT) {
            handleMailToSelf(mail)
        } else if (routingHint == RESPONSE_KEY_HINT) {
            handleKeyResponse(mail)
        } else {
            // TODO handle this case, for demo we will add sealing
            throw IllegalArgumentException("This enclave only does key loading and sharing")
        }
    }

    private fun checkHeaderConstraints(mail: EnclaveMail): EnclaveInstanceInfo {
        val envelope: ByteArray? = mail.envelope // extract the enclave instance info
        if (envelope == null) {
            // This is the case that shouldn't really happen, because our protocol assumes that we put EnclaveInstanceInfo
            // into the header, and then match it against the hardcoded constraints
            throw IllegalArgumentException("Malformed mail without EnclaveInstanceInfo in the header")
        } else {
            val enclaveInstanceInfoFromMail: EnclaveInstanceInfo = EnclaveInstanceInfo.deserialize(envelope) // throws illegal argument exception
            checkAttestationConstraints(enclaveInstanceInfoFromMail)
            return enclaveInstanceInfoFromMail
        }
    }

    // OK
    private fun checkAttestationConstraints(enclaveInstanceInfo: EnclaveInstanceInfo) {
        try {
            keyDerivationEnclaveConstraints.check(enclaveInstanceInfo)
        } catch (e: InvalidEnclaveException) {
            // This is the case where we got provided with the mail with key that doesn't match constraints
            throw IllegalArgumentException("Received mail with EnclaveInstanceInfo in the header that doesn't match constraints")
        }
    }

    // TODO this doesn't make sense, because we have case when we changed machine
    // we could use the key derivation trick maybe?
    private fun checkSender(mail: EnclaveMail) {
        val sender: PublicKey = mail.authenticatedSender
        if (this.signatureKey != sender) {
            // TODO think of this case
            throw java.lang.IllegalArgumentException("TODO")
        }
    }

    // Possible scenarios on key loading from mail to self:
    // 1. header constraints don't match
    //  - means we got key that either is generated by an outdated enclave and we need to perform data migration/request a new key
    //  - means that host fed us old message (replay) - request a new key too
    //  - message is malformed, ie EnclaveInstanceInfo deserialization fails
    // 2. sender doesn't match
    //  - TODO check with Shams, it should probably throw immediately?
    // 3. We cannot decrypt the body - this will throw before the receive TODO check it
    //  - scenario handled by host

    // If this one is called, then it means mail was successfully decrypted, so we need to check constraints
    // and load key
    private fun loadSharedKey(mail: EnclaveMail) {
        // First check the enclave instance info that we received in the header against the hardcoded constraints
        val instanceInfo = checkHeaderConstraints(mail) // throws - THIS SHOULD cause key recovery too
        // Verify that sender is us/ TODO think about it
        checkSender(mail)
        val mailBody = mail.bodyAsBytes
        val keyResponse: KeyDataResponse = ProtoBuf.decodeFromByteArray(KeyDataResponse.serializer(), mail.bodyAsBytes)
        // this happens after the mail got decrypted

        // decrypt the mail body
        // if succesful
        //      extract private key from the body and save it as a cluster key
        //      switch the public key to be a new public key of an enclave
        //      generate new Remote attestation TODO CLUSTER RA
        //      TODO coordinate with the host
        // TODO acknowledge


        /////////////////////////////////////
        TODO()
        // TODO implement scenario for key fallback
        // extract remote attestation from the header
        // verify the remote attestation with the constraint TODO
        // decrypt the mail body
        // if succesful
        //      extract private key from the body and save it as a cluster key
        //      switch the public key to be a new public key of an enclave
        //      generate new Remote attestation TODO CLUSTER RA
        //      TODO coordinate with the host
        // else if not successful
        //      here we have a case we moved machines,
        //      we need to start recovery process using another enclave/cluster/key-vault enclave
        //      exception - host catches
//        val sharedKey: KeyPair = TODO()
//        loadSharedKey(sharedKey)
        // TODO call internal function to load shared key in conclave mail
        // TODO now... attestation ;)
    }

    // TODO this will be different version for Azure
    private fun requestKey() {
        val keyRequest = KeyDataRequest(1) // TODO construct it properly
        // We reuse this function
        keyDerivationEnclaveInstanceInfo = requestAttestation()
        checkAttestationConstraints(keyDerivationEnclaveInstanceInfo)
        // TODO add it to JIRA as a feedback for guys, because it's confusing as hell which function to chose
        // is it createPostOffice
        // or is it postOffice
        // BOTH DO DIFFERENT STUFF :D
//        fun createPostOffice(senderPrivateKey: PrivateKey, topic: String): PostOffice
        // Create post office for communication with the
        val keyDerivationPostOffice = postOffice(keyDerivationEnclaveInstanceInfo)

        val mailBytes = keyDerivationPostOffice.encrypt(keyRequest, KeyDataRequest.serializer())
        postMail(mailBytes, REQUEST_KEY_HINT) // TODO will change the routing hing for host
    }

    private fun requestAttestation(): EnclaveInstanceInfo {
        // we need to load keyDerivationEnclaveInstanceInfo attestation and check it against the constraints we have in code
        // in this case Enclave behaves like a client that checks attestation
        // host is passing messages only, also is untrusted, but attestation makes sure that it works
        // EnclaveInstanceInfo holds the key data, that is used later for the communication
        TODO()
    }

    private fun handleMailToSelf(mail: EnclaveMail) {
        mail.envelope
        val mailBody = mail.bodyAsBytes
        // store secret data for key derivation
        TODO()
    }

    private fun saveSharedKey(sharedKey: KeyPair, keyDerivationRA: EnclaveInstanceInfo) {
        // Get shared key - that would be call on Enclave.sharedKey, for now I just have mock key service here
        val sharedKey = simpleKeyStore.retrieveKey(1) ?: throw IllegalArgumentException("TODO")
        val postOffice = this.enclaveInstanceInfo.createPostOffice()
        val body = sharedKey.serialiseWith(KeyPairSerializer)
        val header = keyDerivationRA.serialize() // header - EnclaveInstanceInfo of the KDE (any)
        val mail = postOffice.encryptMail(body, header)
        postMail(mail, SHARED_KEY_HINT)
    }

    private fun handleKeyResponse(mail: EnclaveMail) {
        // TODO check if we requested key
        //  also check if we have shared key, what happens now, we don't want to overwrite it
        //  check that we trust the KDE by constraints we put in code
        // todo challenge response
        if (keyRequested) {
            loadSharedKey(mail)
//            saveSharedKey()
        } else {
            TODO()
        }
        TODO()
    }

    private fun proveKeyGeneration() {
        // TODO think of that case, we need to have transitive attestation
    }

    ///////////////////////////////////////////// SEALING DEMO
    private fun generateAndSealData() {
        // generate random number
        // send it as mail to self
    }

    private fun readSealedData() {
        // sent as mail to self, read it and print out

    }
    ///////////////////////////////////////////// END SEALING DEMO

    ///////////////////////////////////////////// SERIALIZATION HELPERS REGION
    @ExperimentalSerializationApi
    private fun <T : KeyDataRequest> EnclavePostOffice.encrypt(response: T, serializer: KSerializer<T>): ByteArray {
        return encryptMail(response.serialiseWith(serializer))
    }


    @ExperimentalSerializationApi
    private fun <T> T.serialiseWith(serializer: SerializationStrategy<T>): ByteArray {
        return ProtoBuf.encodeToByteArray(serializer, this)
    }
    ///////////////////////////////////////////// END SERIALIZATION HELPERS REGION

    ///////////////////////////////////////////// AZURE REGION - TODO MOVE IT SEPARATELY TO INTERFACE
    // CONSTRAINTS FOR AZURE
    // REFACTOR: when azure, then different type of authentication, ideally this should be TLS
    private val azureConstraint: PublicKey? = null

    // In Azure case we can't reuse mail protocol communication
    // Moreover we don't have TLS inside enclaves
    // For now this protocol will be authenticated by hardcoded public key
    // TODO there is no protection against replay attacks :/
    override fun receiveFromUntrustedHost(bytes: ByteArray): ByteArray? {
        val result = ByteArray(bytes.size)
        for (i in bytes.indices) result[i] = bytes[bytes.size - 1 - i]
        return result
    }

    private fun handleAzureResponse() {
        TODO()
    }

    private fun azureAttestation() {
        TODO()
    }

    private fun saveAzureKey() {
        TODO()
    }

    private fun loadAzureKey() {
        TODO()
    }
    ///////////////////////////////////////////// END AZURE REGION
}


// This is used when the host delivers a message from the client.
// First, decode mail body as a String.
//        val stringToReverse = String(mail.bodyAsBytes)
//        // Reverse it and re-encode to UTF-8 to send back.
//        val reversedEncodedString: ByteArray = reverse(stringToReverse).toByteArray()
//        // Get the post office object for responding back to this mail and use it to encrypt our response.
//        val responseBytes = postOffice(mail).encryptMail(reversedEncodedString)
//        postMail(responseBytes, routingHint)
