package com.r3.conclave.sample.enclave

import com.r3.conclave.client.EnclaveConstraint
import com.r3.conclave.client.InvalidEnclaveException
import com.r3.conclave.common.EnclaveInstanceInfo
import com.r3.conclave.enclave.Enclave
import com.r3.conclave.enclave.EnclavePostOffice
import com.r3.conclave.mail.EnclaveMail
import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.KSerializer
import kotlinx.serialization.SerializationStrategy
import kotlinx.serialization.protobuf.ProtoBuf
import java.security.KeyPair
import java.security.PublicKey

/**
 * TODO
 */
// TODO no enclave init - JIRA for discussion Shams
@ExperimentalSerializationApi
class AzureAppKeyRecoveryEnclave : Enclave() {
    private val simpleKeyStore = SimpleInMemoryKeyStore()

    // CONSTRAINTS FOR CSS
    // TODO fill it in with real values, it's placeholder
    // btw, they don't have a good story for aythentication of CSS within an enclave, maybe hardcoded key, maybe TLS
    private val azureCloudSealingServiceKey: PublicKey = TODO()

    private val listOfClaims: List<String> = TODO()

    // todo this is probably not needed if we nail the constraints
    // todo think of the overwriting the key and data migration
    private val keyRequested: Boolean = false

    // In Azure case we can't reuse mail protocol communication
    // Moreover we don't have TLS inside enclaves
    // For now this protocol will be authenticated by hardcoded public key
    // TODO there is no protection against replay attacks :/
    override fun receiveFromUntrustedHost(bytes: ByteArray): ByteArray? {
        val result = ByteArray(bytes.size)
        for (i in bytes.indices) result[i] = bytes[bytes.size - 1 - i]
        return result
    }

    // TODO SIDE CHANNELS, think how we could obfuscate the fact that we are handling key request/response
    //  should we have special messages and reserved topic? we need routing coordination from a host perspective anyway...
    override fun receiveMail(id: Long, mail: EnclaveMail, routingHint: String?) {
        routingHint!!  // Ensure that the routingHint isn't null
        // TODO REFACTOR don't pass it as routing hint/reuse header/body
        if (routingHint == SHARED_KEY_HINT) {
            loadSharedKey(mail)
        } else if (routingHint == SELF_HINT) {
            handleMailToSelf(mail)
        } else {
            // TODO handle this case, for demo we will add sealing
            throw IllegalArgumentException("This enclave only does key loading and sharing")
        }
    }

    private fun handleAzureResponse() {
        TODO()
    }

    private fun azureAttestation() {
        TODO()
    }

    private fun saveAzureKey() {
        TODO()
    }

    private fun loadAzureKey() {
        TODO()
    }


    ///////////////////////////////////////////// FILE STUFF, MOVE IT TO INTERFACE FOR BOTH DEMOS
    // Possible scenarios on key loading from mail to self:
    // 1. header constraints don't match
    //  - means we got key that either is generated by an outdated enclave and we need to perform data migration/request a new key
    //  - means that host fed us old message (replay) - request a new key too
    //  - message is malformed, ie EnclaveInstanceInfo deserialization fails
    // 2. sender doesn't match
    //  - TODO check with Shams, it should probably throw immediately?
    // 3. We cannot decrypt the body - this will throw before the receive TODO check it
    //  - scenario handled by host

    // If this one is called, then it means mail was successfully decrypted, so we need to check constraints
    // and load key
    private fun loadSharedKey(mail: EnclaveMail) {
        // First check the enclave instance info that we received in the header against the hardcoded constraints
//        val instanceInfo = checkHeaderConstraints(mail) // throws - THIS SHOULD cause key recovery too
        // Verify that sender is us/ TODO think about it
//        checkSender(mail)
        val mailBody = mail.bodyAsBytes
        val keyResponse: KeyDataResponse = ProtoBuf.decodeFromByteArray(KeyDataResponse.serializer(), mail.bodyAsBytes)
        // this happens after the mail got decrypted

        // decrypt the mail body
        // if succesful
        //      extract private key from the body and save it as a cluster key
        //      switch the public key to be a new public key of an enclave
        //      generate new Remote attestation TODO CLUSTER RA
        //      TODO coordinate with the host
        // TODO acknowledge


        /////////////////////////////////////
        TODO()
        // TODO implement scenario for key fallback
        // extract remote attestation from the header
        // verify the remote attestation with the constraint TODO
        // decrypt the mail body
        // if succesful
        //      extract private key from the body and save it as a cluster key
        //      switch the public key to be a new public key of an enclave
        //      generate new Remote attestation TODO CLUSTER RA
        //      TODO coordinate with the host
        // else if not successful
        //      here we have a case we moved machines,
        //      we need to start recovery process using another enclave/cluster/key-vault enclave
        //      exception - host catches
//        val sharedKey: KeyPair = TODO()
//        loadSharedKey(sharedKey)
        // TODO call internal function to load shared key in conclave mail
        // TODO now... attestation ;)
    }

    private fun handleMailToSelf(mail: EnclaveMail) {
        mail.envelope
        val mailBody = mail.bodyAsBytes
        // store secret data for key derivation
        TODO()
    }

    private fun saveSharedKey(sharedKey: KeyPair, keyDerivationRA: EnclaveInstanceInfo) {
        // Get shared key - that would be call on Enclave.sharedKey, for now I just have mock key service here
        val sharedKey = simpleKeyStore.retrieveKey(1) ?: throw IllegalArgumentException("TODO")
        val postOffice = this.enclaveInstanceInfo.createPostOffice()
        val body = sharedKey.serialiseWith(KeyPairSerializer)
        val header = keyDerivationRA.serialize() // header - EnclaveInstanceInfo of the KDE (any)
        val mail = postOffice.encryptMail(body, header)
        postMail(mail, SHARED_KEY_HINT)
    }


    ///////////////////////////////////////////// SEALING DEMO
    private fun generateAndSealData() {
        // generate random number
        // send it as mail to self
    }

    private fun readSealedData() {
        // sent as mail to self, read it and print out

    }
    ///////////////////////////////////////////// END SEALING DEMO
}


// This is used when the host delivers a message from the client.
// First, decode mail body as a String.
//        val stringToReverse = String(mail.bodyAsBytes)
//        // Reverse it and re-encode to UTF-8 to send back.
//        val reversedEncodedString: ByteArray = reverse(stringToReverse).toByteArray()
//        // Get the post office object for responding back to this mail and use it to encrypt our response.
//        val responseBytes = postOffice(mail).encryptMail(reversedEncodedString)
//        postMail(responseBytes, routingHint)
